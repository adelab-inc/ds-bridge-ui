#!/usr/bin/env node
/**
 * Generate TypeScript files from JSON source
 * Usage: node generate-typescript.js
 */

const fs = require('fs');
const path = require('path');

const FIREBASE_DIR = path.join(__dirname, '../firebase');
const OUTPUT_DIR = path.join(__dirname, '../typescript/firebase');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

/**
 * JSON type to TypeScript type Î≥ÄÌôò
 */
function jsonTypeToTs(field) {
  if (field.enum) {
    return field.enum.map(v => `'${v}'`).join(' | ');
  }
  switch (field.type) {
    case 'string': return 'string';
    case 'number': return 'number';
    case 'boolean': return 'boolean';
    case 'array': return 'any[]';
    case 'object': return 'Record<string, any>';
    default: return 'any';
  }
}

/**
 * snake_case to PascalCase Î≥ÄÌôò
 */
function toPascalCase(str) {
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

/**
 * Generate collections.ts
 */
function generateCollections() {
  const collectionsJson = JSON.parse(
    fs.readFileSync(path.join(FIREBASE_DIR, 'collections.json'), 'utf-8')
  );

  const entries = Object.entries(collectionsJson.collections)
    .map(([key, value]) => `  ${key.toUpperCase()}: '${value.name}'`)
    .join(',\n');

  const output = `/**
 * Firebase Firestore Collection Names
 *
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Source: packages/shared-types/firebase/collections.json
 * Generated by: scripts/generate-typescript.js
 */

export const COLLECTIONS = {
${entries}
} as const;

export type CollectionName = typeof COLLECTIONS[keyof typeof COLLECTIONS];
`;

  fs.writeFileSync(path.join(OUTPUT_DIR, 'collections.ts'), output);
  console.log('‚úÖ Generated: typescript/firebase/collections.ts');
}

/**
 * Generate types.ts from collection fields
 */
function generateTypes() {
  const collectionsJson = JSON.parse(
    fs.readFileSync(path.join(FIREBASE_DIR, 'collections.json'), 'utf-8')
  );

  const interfaces = [];
  const enumDefs = [];

  for (const [collectionKey, collection] of Object.entries(collectionsJson.collections)) {
    if (!collection.fields) continue;

    const interfaceName = toPascalCase(collectionKey.replace(/s$/, '')); // chat_rooms -> ChatRoom

    // Check for enum fields to create type aliases
    for (const [fieldName, field] of Object.entries(collection.fields)) {
      if (field.enum) {
        const enumTypeName = toPascalCase(fieldName);
        enumDefs.push(`/**
 * ${field.description || fieldName}
 */
export type ${enumTypeName} = ${field.enum.map(v => `'${v}'`).join(' | ')};`);
      }
    }

    // Generate interface fields
    const fields = Object.entries(collection.fields)
      .map(([fieldName, field]) => {
        const tsType = field.enum ? toPascalCase(fieldName) : jsonTypeToTs(field);
        const comment = field.description ? `  /** ${field.description} */\n` : '';
        return `${comment}  ${fieldName}: ${tsType};`;
      })
      .join('\n');

    const interfaceCode = `/**
 * ${collection.description}
 * Collection: ${collection.name}
 */
export interface ${interfaceName} {
${fields}
}`;

    interfaces.push(interfaceCode);
  }

  // Combine enums first, then interfaces
  const allTypes = [...enumDefs, ...interfaces];

  const output = `/**
 * Firebase Firestore Document Types
 *
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Source: packages/shared-types/firebase/collections.json
 * Generated by: scripts/generate-typescript.js
 */

${allTypes.join('\n\n')}
`;

  fs.writeFileSync(path.join(OUTPUT_DIR, 'types.ts'), output);
  console.log('‚úÖ Generated: typescript/firebase/types.ts');
}

/**
 * Generate storage.ts
 */
function generateStorage() {
  const storageJson = JSON.parse(
    fs.readFileSync(path.join(FIREBASE_DIR, 'storage.json'), 'utf-8')
  );

  const entries = Object.entries(storageJson.paths)
    .map(([key, value]) => `  ${key.toUpperCase()}: '${value.path}'`)
    .join(',\n');

  const output = `/**
 * Firebase Storage Paths
 *
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Source: packages/shared-types/firebase/storage.json
 * Generated by: scripts/generate-typescript.js
 */

export const STORAGE_PATHS = {
${entries}
} as const;

export type StoragePath = typeof STORAGE_PATHS[keyof typeof STORAGE_PATHS];
`;

  fs.writeFileSync(path.join(OUTPUT_DIR, 'storage.ts'), output);
  console.log('‚úÖ Generated: typescript/firebase/storage.ts');
}

/**
 * Generate index.ts
 */
function generateIndex() {
  const output = `/**
 * Firebase Shared Configuration
 *
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-typescript.js
 */

export * from './collections';
export * from './storage';
export * from './types';
`;

  fs.writeFileSync(path.join(OUTPUT_DIR, 'index.ts'), output);
  console.log('‚úÖ Generated: typescript/firebase/index.ts');
}

// Run
try {
  console.log('üîÑ Generating TypeScript files...\n');
  generateCollections();
  generateTypes();
  generateStorage();
  generateIndex();
  console.log('\n‚ú® TypeScript generation complete!');
} catch (error) {
  console.error('‚ùå Error generating TypeScript files:', error.message);
  process.exit(1);
}

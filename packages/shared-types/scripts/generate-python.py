#!/usr/bin/env python3
"""
Generate Python files from JSON source
Usage: python generate-python.py
"""

import json
import os
from pathlib import Path

FIREBASE_DIR = Path(__file__).parent.parent / "firebase"
OUTPUT_DIR = Path(__file__).parent.parent / "python" / "firebase"


def ensure_output_dir():
    """Ensure output directory exists"""
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)


def snake_to_pascal_case(text: str) -> str:
    """Convert snake_case to PascalCase"""
    return ''.join(word.capitalize() for word in text.split('_'))


def generate_field_type(field: dict) -> str:
    """Generate Python type annotation from schema field"""
    field_type = field.get("type")
    
    if field_type == "string":
        return "str"
    elif field_type == "boolean":
        return "bool"
    elif field_type == "number":
        return "float"
    elif field_type == "timestamp":
        return "datetime"
    elif field_type == "enum" and "values" in field:
        values = ", ".join(f'"{v}"' for v in field["values"])
        return f"Literal[{values}]"
    else:
        return "Any"


def generate_typed_dict(collection_key: str, schema: dict) -> str:
    """Generate TypedDict class from schema"""
    class_name = snake_to_pascal_case(collection_key) + "Document"
    
    fields = []
    for field_name, field_config in schema.items():
        field_type = generate_field_type(field_config)
        required = field_config.get("required", False)
        description = field_config.get("description", "")
        
        if description:
            fields.append(f'    # {description}')
        
        # NotRequired for optional fields (Python 3.11+)
        if not required:
            field_type = f"NotRequired[{field_type}]"
        
        fields.append(f'    {field_name}: {field_type}')
    
    return f'class {class_name}(TypedDict):\n    """Document schema for {collection_key} collection"""\n\n' + '\n'.join(fields)


def generate_collections():
    """Generate collections.py"""
    with open(FIREBASE_DIR / "collections.json") as f:
        data = json.load(f)

    # Generate Collections class
    entries = []
    for key, value in data["collections"].items():
        const_name = key.upper()
        collection_name = value["name"]
        description = value["description"]
        entries.append(f'    {const_name} = "{collection_name}"  # {description}')

    # Generate TypedDict classes from schemas
    typed_dicts = []
    needs_datetime = False
    needs_literal = False
    needs_not_required = False
    
    for key, value in data["collections"].items():
        if "schema" in value:
            typed_dict = generate_typed_dict(key, value["schema"])
            typed_dicts.append(typed_dict)
            
            # Check if we need special imports
            schema_str = json.dumps(value["schema"])
            if '"type": "timestamp"' in schema_str:
                needs_datetime = True
            if '"type": "enum"' in schema_str:
                needs_literal = True
            if '"required": false' in schema_str:
                needs_not_required = True

    # Build imports
    imports = ["from typing import TypedDict"]
    if needs_literal:
        imports[0] = "from typing import Literal, TypedDict"
    if needs_not_required:
        imports.append("from typing_extensions import NotRequired")
    if needs_datetime:
        imports.append("from datetime import datetime")
    
    imports_str = '\n'.join(imports)
    typed_dicts_str = '\n\n\n'.join(typed_dicts)

    output = f'''\"\"\"\nFirebase Firestore Collection Names and Document Types\n\n‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY\nSource: packages/shared-types/firebase/collections.json\nGenerated by: scripts/generate-python.py\n\"\"\"\n\n{imports_str}\n\n\nclass Collections:\n    \"\"\"Firestore collection names\"\"\"\n\n{chr(10).join(entries)}\n\n\n{typed_dicts_str}\n'''

    with open(OUTPUT_DIR / "collections.py", "w") as f:
        f.write(output)

    print("‚úÖ Generated: python/firebase/collections.py")


def generate_storage():
    """Generate storage.py"""
    with open(FIREBASE_DIR / "storage.json") as f:
        data = json.load(f)

    entries = []
    for key, value in data["paths"].items():
        const_name = key.upper()
        path_name = value["path"]
        description = value["description"]
        entries.append(f'    {const_name} = "{path_name}"  # {description}')

    output = '''"""
Firebase Storage Paths

‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
Source: packages/shared-types/firebase/storage.json
Generated by: scripts/generate-python.py
"""


class StoragePaths:
    """Firebase Storage path constants"""

{entries}
'''.format(entries='\n'.join(entries))

    with open(OUTPUT_DIR / "storage.py", "w") as f:
        f.write(output)

    print("‚úÖ Generated: python/firebase/storage.py")


def generate_init():
    """Generate __init__.py"""
    output = '''"""
Firebase Shared Configuration

‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
Generated by: scripts/generate-python.py
"""

from .collections import Collections
from .storage import StoragePaths

__all__ = ["Collections", "StoragePaths"]
'''

    with open(OUTPUT_DIR / "__init__.py", "w") as f:
        f.write(output)

    print("‚úÖ Generated: python/firebase/__init__.py")


def main():
    """Run generation"""
    try:
        print("üîÑ Generating Python files...\n")
        ensure_output_dir()
        generate_collections()
        generate_storage()
        generate_init()
        print("\n‚ú® Python generation complete!")
    except Exception as e:
        print(f"‚ùå Error generating Python files: {e}")
        exit(1)


if __name__ == "__main__":
    main()
